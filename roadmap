0.01

  wwid new
  wwid next
  wwid recalculate
  wwid finish
  wwid help
  wwid import
  value - effort algorithm

Later

  wwid search
  wwid export
  wwid checkin
  wwid sync (sync with another instance)
  Interactive input of missing options
  Web application (wwid serve)
  Android application
  Arbitrary metadata asociated with tasks
  Hooks for events (upon completion, etc)

App-Subcommander tests:

Now:

  - show help (no command, bad command, help command w/o args)
  - help with a command (cmd help $cmd)
  - app options (--config preceding subcommand)
  - type map stuff (Effort $e)
  - Return value for run?
  - short options (-s) (add-on role, automatic setup a separate add-on role)
      - argument bundling (add-on role)
  - negated boolean flags (no, no-, make sure this wouldn't clash with --node)
  - option terminator (--)
  - What if I have name and pseudonym, but I specify both? (if it's *not* an array parameter)
    - Test if it is an array parameter
  - What if I have $name and @name (I think the compiler would reject this)
  - What if I have a positional array or hash parameter?
  - --foo --bar ‚Üê fail
  - --foo val1 --foo val2
  - --foo -- --bar should work
  - optional Int (make sure the type information makes it into determine-type-info)
  - Missing options for list options
  - Int :@options
  - What happens if I *don't* specify a subcommand?

Later:

  - Document how slurpies all share the same type
  - Should we worry if a non-Str is passed to run?
  - What if command and app options clash?
  - What if a subcommand nextsame's its parent?  pos/named args?
  - how will --config work (if I have something like --interactive?)
  - what if the value for an option is optional? (ex. --password)
  - multis

Extensions:

  - Shortened subcommand names
  - Interactive input of missing options
  - bash/zsh completion generation?
  - non-strict mode wrt. extra options
  - What if I want a default subcommand?
