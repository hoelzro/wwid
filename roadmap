0.01

  wwid new
  wwid next
  wwid recalculate
  wwid finish
  wwid help
  wwid import
  value - effort algorithm

Later

  wwid search
  wwid export
  wwid checkin
  wwid sync (sync with another instance)
  Interactive input of missing options
  Web application (wwid serve)
  Android application
  Arbitrary metadata asociated with tasks
  Hooks for events (upon completion, etc)

App-Subcommander tests:

Now:

  - show help (no command, bad command, help command w/o args)
  - help with a command (cmd help $cmd)
  - app options (--config preceding subcommand)
  - type map stuff (Effort $e)
  - Return value for run?
  - short options (-s) (add-on role, automatic setup a separate add-on role)
      - argument bundling (add-on role)
  - What happens if I *don't* specify a subcommand?
  - An unrecognized option prompts for a value if none is given (there should be a different error message)
  - cmd foo -- -- bar # ['foo', '--', 'bar']
  - Make TypeResolver and co into 'our' roles, make DefaultTypeResolver and friends
  - Allow users to pass constructors for TypeResolver and such into BUILD
  - If help wasn't expected, we should display any messages displayed
  - Figure out the relationship between the TypeResolver and canonical names...
  - The Bool check in parse-option should probably be something like "doesn't require value"

Later:

  - Document how slurpies all share the same type
  - Should we worry if a non-Str is passed to run?
  - What if command and app options clash?
  - What if a subcommand nextsame's its parent?  pos/named args?
  - how will --config work (if I have something like --interactive?)
  - what if the value for an option is optional? (ex. --password)
  - multis

Extensions:

  - Shortened subcommand names
  - Interactive input of missing options
  - bash/zsh completion generation?
  - non-strict mode wrt. extra options
  - What if I want a default subcommand?
